// Generated by LiveScript 1.4.0
(function(){
  var tagged, contains, has, checkField, before, after, getQuotedString, makeNot, makeOr, getParenString, getUntilCloser, philtreCore, philtre, out$ = typeof exports != 'undefined' && exports || this;
  tagged = curry$(function(tag, item){
    var ref$;
    return -1 < ((ref$ = item.tags) != null ? ref$.indexOf(tag) : void 8);
  });
  contains = curry$(function(string, item){
    var key;
    for (key in item) {
      if (-1 < item[key].indexOf(string)) {
        return true;
      }
    }
    return false;
  });
  has = curry$(function(field, item){
    return item != null ? item[field] : void 8;
  });
  checkField = curry$(function(field, value, item){
    var ref$;
    return -1 < (item != null ? (ref$ = item[field]) != null ? ref$.toString().indexOf(value) : void 8 : void 8);
  });
  before = curry$(function(date, item){
    return item.date < date;
  });
  after = curry$(function(date, item){
    return item.date > date;
  });
  getQuotedString = function(str){
    var opener;
    opener = str[0];
    str = str.substr(1);
    return getUntilCloser(str, opener);
  };
  makeNot = function(f){
    return function(it){
      return !f(it);
    };
  };
  makeOr = function(a, b){
    return function(it){
      return a(it) || b(it);
    };
  };
  getParenString = function(str){
    str = str.substr(1);
    return getUntilCloser(str, ")");
  };
  getUntilCloser = function(str, closer){
    var out, char;
    out = '';
    while (str.length > 0) {
      char = str[0];
      str = str.substr(1);
      if (char === closer) {
        return [out, str];
      }
      if (char === "\\") {
        out += str[0];
        str = str.substr(1);
        continue;
      }
      out += char;
    }
  };
  philtreCore = function(query){
    var conds, ref$, word, key, value, ucw, condsOut, ii;
    conds = [];
    while (query.length > 0) {
      if (query[0] === "(") {
        ref$ = getParenString(query), word = ref$[0], query = ref$[1];
        conds.push(philtreCore(word));
        continue;
      }
      if (query[0] === "-") {
        conds.push("NOT");
        query = query.substr(1);
        continue;
      }
      if (query[0] === '#') {
        query = query.substr(1);
        if (-1 < query.indexOf(' ')) {
          word = query.substr(0, query.indexOf(' '));
        } else {
          word = query;
        }
        query = query.substr(1 + word.length);
        conds.push(tagged(word));
        continue;
      }
      if (query.match(/^[A-z]*:/)) {
        key = query.substr(0, query.indexOf(":"));
        query = query.substr(1 + query.indexOf(":"));
        if (query[0] === '"' || query[0] === '\'') {
          ref$ = getQuotedString(query), value = ref$[0], query = ref$[1];
        } else {
          if (-1 < query.indexOf(' ')) {
            value = query.substr(0, query.indexOf(' '));
          } else {
            value = query;
          }
          query = query.substr(1 + value.length);
        }
        conds.push((fn$()));
        continue;
      }
      if (query[0] === '"' || query[0] === '\'') {
        ref$ = getQuotedString(query), word = ref$[0], query = ref$[1];
      } else {
        if (-1 < query.indexOf(' ')) {
          word = query.substr(0, query.indexOf(' '));
        } else {
          word = query;
        }
        query = query.substr(1 + word.length);
      }
      ucw = word.toUpperCase();
      if (ucw === "AND") {
        continue;
      }
      if (ucw === "OR" || ucw === "NOT") {
        conds.push(ucw);
        continue;
      }
      if (word === '') {
        continue;
      }
      conds.push(contains(word));
      continue;
    }
    condsOut = [];
    ii = 0;
    while (ii < conds.length) {
      if (conds[ii + 1] === "OR") {
        condsOut.push(makeOr(conds[ii], conds[ii + 2]));
        ii += 3;
        continue;
      }
      if (conds[ii] === "NOT") {
        condsOut.push(makeNot(conds[ii + 1]));
        ii += 2;
        continue;
      }
      condsOut.push(conds[ii]);
      ii += 1;
    }
    return function(it){
      var i$, ref$, len$, f;
      for (i$ = 0, len$ = (ref$ = condsOut).length; i$ < len$; ++i$) {
        f = ref$[i$];
        if (!f(it)) {
          return false;
        }
      }
      return true;
    };
    function fn$(){
      switch (key) {
      case 'is':
      case 'has':
        return has(value);
      case 'before':
        return before(value);
      case 'after':
        return after(value);
      default:
        return checkField(key, value);
      }
    }
  };
  out$.philtre = philtre = curry$(function(query, items){
    var conds;
    query = query.trim();
    conds = philtreCore(query);
    return items.filter(conds);
  });
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
