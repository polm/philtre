// Generated by LiveScript 1.4.0
(function(){
  var tagged, contains, has, before, after, philtreCore, philtre, out$ = typeof exports != 'undefined' && exports || this;
  tagged = curry$(function(tag, item){
    var ref$;
    return -1 < ((ref$ = item.tags) != null ? ref$.indexOf(tag) : void 8);
  });
  contains = curry$(function(string, item){
    var key;
    for (key in item) {
      if (-1 < item[key].indexOf(string)) {
        return true;
      }
    }
    return false;
  });
  has = curry$(function(field, item){
    return item != null ? item[field] : void 8;
  });
  before = curry$(function(date, item){
    return item.date < date;
  });
  after = curry$(function(date, item){
    return item.date > date;
  });
  philtreCore = function(query){
    var conds, word, token, ref$, key, value;
    conds = [];
    while (query.length > 0) {
      if (query[0] === '#') {
        word = query.split(' ')[0].substr(1);
        query = query.substr(2 + word.length);
        conds.push(tagged(word));
        continue;
      }
      /*
      if query.0 == '"' or query.0 == "'" # this is a quoted string
        word = ''
        opener = query.0
        query.shift!
        while query.length > 0
          char = query.shift!
          if char == opener then break # found closing quote
          if char == "\\" # escape
            # this will blow up if the last character is a backslash, that's fine
            word += query.shift!
            continue
          word += char
        # now word is the quoted string
        conds.push contains word
        query = query.trim!
        continue
      */
      if (-1 < query.indexOf(":")) {
        token = query.split(' ')[0];
        ref$ = token.split(':'), key = ref$[0], value = ref$[1];
        switch (key) {
        case 'is':
        case 'has':
          conds.push(has(value));
          break;
        case 'before':
          conds.push(before(value));
          break;
        case 'after':
          conds.push(after(value));
          break;
        default:
          conds.push(fn$);
        }
        query = query.substr(key.length + value.length + 1);
        continue;
      }
      word = query.split(' ')[0];
      query = query.substr(1 + word.length);
      conds.push(contains(word));
    }
    return conds;
    function fn$(){
      return false;
    }
  };
  out$.philtre = philtre = function(query){
    var conds;
    query = query.trim();
    conds = philtreCore(query);
    return function(items){
      return items.filter(function(it){
        var i$, ref$, len$, f;
        for (i$ = 0, len$ = (ref$ = conds).length; i$ < len$; ++i$) {
          f = ref$[i$];
          if (!f(it)) {
            return false;
          }
        }
        return true;
      });
    };
  };
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
