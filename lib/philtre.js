// Generated by LiveScript 1.4.0
(function(){
  var parser, philtre, sortBy, makeFunc, makeAnd, makeOr, funkifyTerm, tagged, contains, checkField, before, after, out$ = typeof exports != 'undefined' && exports || this;
  parser = require('../lib/parser.js');
  out$.philtre = philtre = curry$(function(query, items){
    var func, output;
    query = query.trim();
    if (query === '') {
      func = function(){
        return true;
      };
    } else {
      func = makeFunc(parser.parse(query));
    }
    output = items.filter(func);
    if (func.sort) {
      output = sortBy(func.sort.rev, func.sort.field, output);
    }
    if (func.limit) {
      output = output.slice(0, func.limit);
    }
    return output;
  });
  sortBy = curry$(function(rev, field, items){
    var swap, itemsCopy;
    swap = 1;
    if (rev) {
      swap = -1;
    }
    itemsCopy = items.slice(0);
    return itemsCopy.sort(function(a, b){
      if (a[field] < b[field]) {
        return swap * -1;
      }
      if (a[field] > b[field]) {
        return swap * 1;
      }
      return 0;
    });
  });
  makeFunc = function(q){
    var conds, sort, limit, i$, len$, term, cond, outFunc;
    conds = [];
    sort = false;
    limit = false;
    for (i$ = 0, len$ = q.length; i$ < len$; ++i$) {
      term = q[i$];
      cond = funkifyTerm(term);
      if (cond.sort) {
        sort = cond.sort;
      } else if (cond.limit) {
        limit = cond.limit;
      } else {
        conds.push(cond);
      }
    }
    outFunc = function(item){
      var i$, ref$, len$, cond;
      for (i$ = 0, len$ = (ref$ = conds).length; i$ < len$; ++i$) {
        cond = ref$[i$];
        if (!cond(item)) {
          return false;
        }
      }
      return true;
    };
    outFunc.sort = sort;
    outFunc.limit = limit;
    return outFunc;
  };
  makeAnd = function(q){
    var a, b;
    a = funkifyTerm(q[0]);
    b = funkifyTerm(q[1]);
    return function(it){
      return a(it) && b(it);
    };
  };
  makeOr = function(q){
    var a, b;
    a = funkifyTerm(q[0]);
    b = funkifyTerm(q[1]);
    return function(it){
      return a(it) || b(it);
    };
  };
  funkifyTerm = function(term){
    if (term.subquery) {
      return makeFunc(term.subquery);
    }
    if (term.not) {
      return function(it){
        return !funkifyTerm(term.not)(it);
      };
    }
    if (term.literal) {
      return contains(term.literal);
    }
    if (term.and) {
      return makeAnd(term.and);
    }
    if (term.or) {
      return makeOr(term.or);
    }
    if (term.key && term.val) {
      return checkField(term.key, funkifyTerm(term.val));
    }
    if (term.tag) {
      return tagged(term.tag);
    }
    if (term.lessthan) {
      return function(it){
        return it < term.lessthan;
      };
    }
    if (term.lessthaneq) {
      return function(it){
        return it <= term.lessthaneq;
      };
    }
    if (term.greaterthan) {
      return function(it){
        return it > term.greaterthan;
      };
    }
    if (term.greaterthaneq) {
      return function(it){
        return it >= term.greaterthaneq;
      };
    }
    if (term.builtin) {
      return (function(){
        switch (term.builtin) {
        case 'sort':
          return {
            sort: {
              field: term.val
            }
          };
        case 'sortr':
          return {
            sort: {
              rev: true,
              field: term.val
            }
          };
        case 'limit':
          return {
            limit: +term.val
          };
        case 'before':
          return before(term.val);
        case 'after':
          return after(term.val);
        case 'is' || 'has':
          return function(it){
            return it[term.val] != null;
          };
        }
      }());
    }
    throw "Unknown term: " + term.toString();
  };
  tagged = curry$(function(tag, item){
    var ref$;
    return -1 < ((ref$ = item.tags) != null ? ref$.indexOf(tag) : void 8);
  });
  contains = curry$(function(string, item){
    var option, reg, key, ref$;
    option = 'i';
    if (string.match(/[A-Z]/)) {
      option = '';
    }
    reg = new RegExp(string, option);
    if (item != null && item.match) {
      return item.match(reg);
    }
    for (key in item) {
      if ((ref$ = item[key]) != null && (typeof ref$.toString == 'function' && ref$.toString().match(reg))) {
        return true;
      }
    }
    return false;
  });
  checkField = curry$(function(field, func, item){
    return func(item[field]);
  });
  before = curry$(function(date, item){
    return item.date < date;
  });
  after = curry$(function(date, item){
    return item.date > date;
  });
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
